{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pysenxor","text":"<p>A Python Library for Meridian Innovation's thermal imaging devices.</p> <ul> <li>Github repository: https://github.com/MeridianInnovation/pysenxor-lite/</li> <li>Documentation https://MeridianInnovation.github.io/pysenxor-lite/</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>This package can let users interact with Meridian Innovation's thermal imaging devices.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Device discovery and listing</li> <li>Multiple interfaces supported(USB serial, TCP/IP, GPIO, etc.)(Coming soon)</li> <li>Easy device connection and management</li> <li>Configuration and status read and write</li> <li>Non-blocking mode for frame reading</li> <li>Thermal data processing utilities</li> <li>Thread-safe for multi-threaded use</li> <li>Lightweight and minimal dependencies(no cv2 or matplotlib required)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the project, run the following command:</p> <pre><code>python -m pip install git+https://github.com/MeridianInnovation/pysenxor-lite.git\n\n# Install from local:\ngit clone https://github.com/MeridianInnovation/pysenxor-lite.git\ncd pysenxor-lite\npython -m pip install .\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Tutorials</li> <li>API Reference</li> </ul>"},{"location":"development_rules/","title":"Development Rules","text":"<p>This document outlines the coding standards and best practices for the pysenxor project.</p> <p>It can be used to guide AI agent development behavior and ensure consistent development standards.</p>"},{"location":"development_rules/#development-environment","title":"Development Environment","text":""},{"location":"development_rules/#tools","title":"Tools","text":"<ul> <li>uv: Package manager and virtual environment tool for Python</li> <li>Create virtual environment: <code>uv venv --seed</code></li> <li>Install dependencies: <code>uv sync</code></li> <li>Install doc dependencies: <code>uv sync --group doc</code></li> <li> <p>Run commands or scripts: <code>uv run pytest</code>, <code>uv run example/basic_stream.py</code></p> </li> <li> <p>mkdocs-material: Documentation system</p> </li> <li>Build documentation: <code>uv run mkdocs build</code></li> <li>Serve documentation locally: <code>uv run mkdocs serve</code></li> <li>Uses <code>mkdocstrings[python]</code> to extract docstrings and generate API reference</li> </ul>"},{"location":"development_rules/#logging-guidelines","title":"Logging Guidelines","text":""},{"location":"development_rules/#structured-logging","title":"Structured Logging","text":"<p>We use <code>structlog</code> for logging to provide consistent, machine-parseable logs.</p>"},{"location":"development_rules/#general-rules","title":"General Rules","text":"<ul> <li>Use short, concise log messages (ideally 2-10 words)</li> <li>Avoid f-strings in log messages</li> <li>Pass contextual data as keyword arguments</li> <li>Use <code>bind()</code> to attach context to loggers</li> <li>Keep log messages in English, even in international projects</li> </ul>"},{"location":"development_rules/#message-style","title":"Message Style","text":"<pre><code># Good\nlogger.info(\"connection established\", address=addr)\nlogger.debug(\"frame received\", shape=frame.shape, timestamp=ts)\nlogger.error(\"read failed\", exc_info=exc, attempts=retry_count)\n\n# Bad - using f-strings\nlogger.info(f\"Connection established to {addr}\")\n\n# Bad - too verbose\nlogger.info(\"Successfully established a new connection to the remote server at the specified address and port\")\n</code></pre>"},{"location":"development_rules/#common-log-fields","title":"Common Log Fields","text":"<p>Standardize field names across the codebase:</p> Field Name Description Example <code>address</code> Device address <code>\"COM3\"</code> <code>shape</code> Data dimensions <code>(32, 32)</code> <code>size</code> Data size <code>1024</code> <code>count</code> Number of items <code>5</code> <code>status</code> Operation status <code>\"success\"</code> <p>Note: To keep consistency, shape is always (height, width) to adopt numpy's convention. dsize is always (width, height). size is always for the 1-dim array.</p>"},{"location":"development_rules/#logger-creation","title":"Logger Creation","text":"<pre><code># Module-level logger\nfrom structlog import get_logger\nlogger = get_logger(\"senxor.module_name\")\n\n# Context-bound logger\nself._log = logger.bind(address=address)\n</code></pre>"},{"location":"development_rules/#log-levels","title":"Log Levels","text":"<ul> <li><code>debug</code>: Detailed information, typically of interest only when diagnosing problems</li> <li><code>info</code>: Confirmation that things are working as expected</li> <li><code>warning</code>: Indication that something unexpected happened, but the application still works</li> <li><code>error</code>: Due to a more serious problem, the application has not been able to perform a function</li> <li><code>exception</code>: An exception occurred, should exit the program</li> </ul>"},{"location":"development_rules/#error-vs-exception-logging","title":"Error vs Exception Logging","text":"<ul> <li>Use <code>logger.error()</code> when you want to log an error condition without the stack trace</li> <li>Use <code>logger.exception()</code> when you want to include the stack trace and raise the exception</li> </ul> <pre><code># Good - log error without stack trace\nlogger.error(\"connection failed\", address=addr)\n\n# Good - log exception with stack trace\ntry:\n    connect_to_device(addr)\nexcept ConnectionError as e:\n    logger.exception(\"connection failed\", address=addr)\n    raise\n</code></pre>"},{"location":"development_rules/#error-handling","title":"Error Handling","text":""},{"location":"development_rules/#exception-messages","title":"Exception Messages","text":"<ul> <li>Exception messages should be descriptive and helpful</li> <li>Use complete sentences with proper capitalization</li> <li>Include specific details about what went wrong</li> <li>Include guidance on how to fix the issue when appropriate</li> <li>Exception messages can be longer than log messages (medium length)</li> <li>Simple, clear messages are preferred when the error is self-explanatory</li> </ul> <pre><code># Good\nraise ValueError(\"A listener with name 'my_listener' already exists\")\nraise TimeoutError(\n    \"Listener processing backlog detected: previous data is still being processed.\",\n    \"Ensure all listener callbacks are lightweight and non-blocking.\",\n)\nraise ConnectionError(\"Senxor not connected\")\n\n# Bad - too short/cryptic\nraise ValueError(\"duplicate name\")\nraise TimeoutError(\"processing timeout\")\n\n# Bad - too verbose\nraise ValueError(\"The system has detected that you are attempting to add a listener with a name that is already registered in the internal listener registry, which is not allowed because listener names must be unique within a single reader instance.\")\n</code></pre>"},{"location":"development_rules/#error-handling-patterns","title":"Error Handling Patterns","text":"<ul> <li>Use specific exception types that match the error condition</li> <li>Catch exceptions at the appropriate level</li> <li>Use <code>contextlib.suppress</code> for ignoring specific exceptions during cleanup</li> <li>Include context in exception messages</li> </ul> <pre><code># Good - specific exception with context\nif name in self._listeners:\n    raise ValueError(f\"A listener with name '{name}' already exists\")\n\n# Good - suppressing exceptions during cleanup\nwith contextlib.suppress(Exception):\n    self._reader.stop()\n</code></pre>"},{"location":"development_rules/#balancing-log-messages-and-exceptions","title":"Balancing Log Messages and Exceptions","text":"<ul> <li>Log Messages: Short, concise, focused on the event</li> <li>Exception Messages: More detailed, focused on explaining the problem and potential solutions</li> </ul> <p>Example:</p> <pre><code># Log message is short\nself._log.error(\"listener timeout\")\n\n# Exception message is more detailed\nraise TimeoutError(\n    \"Listener processing backlog detected: previous data is still being processed.\",\n    \"Ensure all listener callbacks are lightweight and non-blocking.\",\n)\n</code></pre>"},{"location":"development_rules/#code-organization","title":"Code Organization","text":""},{"location":"development_rules/#class-structure","title":"Class Structure","text":"<ul> <li>Place public methods first</li> <li>Group related methods together</li> <li>Use private methods (with <code>_</code> prefix) for implementation details</li> <li>Implement special methods (<code>__enter__</code>, <code>__exit__</code>, etc.) at the end of the class</li> </ul>"},{"location":"development_rules/#threading-patterns","title":"Threading Patterns","text":"<ul> <li>Use descriptive thread names for debugging</li> <li>Always join threads during cleanup</li> <li>Use locks to protect shared resources</li> <li>Set daemon=True for background threads</li> <li>Use events for signaling between threads</li> </ul> <pre><code>self._reader_thread = threading.Thread(\n    target=self._run,\n    name=f\"{self._name}Read\",\n    daemon=True,\n)\n</code></pre>"},{"location":"development_rules/#documentation","title":"Documentation","text":""},{"location":"development_rules/#docstrings","title":"Docstrings","text":"<ul> <li>Use NumPy-style docstrings for all public methods and classes</li> <li>Document parameters, return values, and exceptions</li> <li>Include examples for complex functionality</li> </ul> <pre><code>def add_listener(self, fn: Callable[[Any], None], name: str | None = None) -&gt; str:\n    \"\"\"Register a listener callback.\n\n    Parameters\n    ----------\n    fn\n        Callable invoked with the latest data object. **Must be\n        lightweight and non-blocking**.\n    name\n        Optional unique identifier. If omitted, an automatic ``listener_X``\n        name is assigned.\n\n    Returns\n    -------\n    str\n        The listener name actually registered.\n\n    Raises\n    ------\n    RuntimeError\n        If the listener pattern is disabled.\n    ValueError\n        If *name* already exists.\n    \"\"\"\n</code></pre>"},{"location":"development_rules/#testing","title":"Testing","text":""},{"location":"development_rules/#test-structure","title":"Test Structure","text":"<ul> <li>Use pytest for testing</li> <li>Group tests by class/module in test files</li> <li>Use descriptive test names that explain what is being tested</li> <li>Use fixtures for common setup</li> <li>Mock external dependencies</li> </ul>"},{"location":"development_rules/#test-coverage","title":"Test Coverage","text":"<ul> <li>Test happy paths (normal operation)</li> <li>Test edge cases and error conditions</li> <li>Test thread safety for concurrent code</li> <li>Test resource cleanup</li> </ul> <pre><code>def test_slow_listener(self, mock_reader_func):\n    \"\"\"Test that slow listeners cause TimeoutError.\"\"\"\n    reader = _BackgroundReader(mock_reader_func, \"SlowListener\")\n\n    # Create a slow listener that blocks\n    def slow_listener(data):\n        time.sleep(0.5)  # Block for a long time\n\n    reader.add_listener(slow_listener)\n    reader.start()\n\n    # Wait for the first notification to start\n    time.sleep(0.1)\n\n    # Force a second read while the first is still processing\n    # This should raise a TimeoutError in the reader thread\n    with patch.object(reader, \"_reader_func\") as mock_read:\n        # Make sure the mock returns a value\n        mock_read.return_value = 999\n\n        # Call _read_once directly to simulate the reader thread\n        with pytest.raises(TimeoutError, match=\"Listener processing backlog detected\"):\n            reader._read_once()\n</code></pre>"},{"location":"development_rules/#code-examples-and-usage-patterns","title":"Code Examples and Usage Patterns","text":""},{"location":"development_rules/#example-code-in-documentation","title":"Example Code in Documentation","text":"<ul> <li>Include usage examples in module and class docstrings</li> <li>Show both simple and advanced use cases</li> <li>Highlight best practices and common patterns</li> </ul> <pre><code>\"\"\"\nExamples\n--------\nBasic usage:\n\n&gt;&gt;&gt; from senxor import SenxorThread\n&gt;&gt;&gt; with SenxorThread(\"COM3\") as senxor:\n...     header, frame = senxor.read()\n...     process_frame(frame)\n\nUsing the listener pattern:\n\n&gt;&gt;&gt; def on_new_frame(header, frame):\n...     print(f\"New frame received: {frame.shape}\")\n...\n&gt;&gt;&gt; with SenxorThread(\"COM3\") as senxor:\n...     senxor.add_listener(on_new_frame)\n...     time.sleep(5)  # Process frames in background\n\"\"\"\n</code></pre>"},{"location":"development_rules/#common-design-patterns","title":"Common Design Patterns","text":""},{"location":"development_rules/#consumer-producer-pattern","title":"Consumer-Producer Pattern","text":"<pre><code># Producer thread\ndef producer():\n    while running:\n        data = generate_data()\n        queue.put(data)\n\n# Consumer thread\ndef consumer():\n    while running:\n        data = queue.get()\n        process_data(data)\n        queue.task_done()\n</code></pre>"},{"location":"development_rules/#observerlistener-pattern","title":"Observer/Listener Pattern","text":"<pre><code>class Subject:\n    def __init__(self):\n        self._listeners = {}\n\n    def add_listener(self, fn, name=None):\n        # Add listener implementation\n\n    def remove_listener(self, name):\n        # Remove listener implementation\n\n    def notify_listeners(self, data):\n        # Notify all listeners\n</code></pre>"},{"location":"development_rules/#background-processing-pattern","title":"Background Processing Pattern","text":"<pre><code>class BackgroundProcessor:\n    def __init__(self):\n        self._thread = None\n        self._running = False\n\n    def start(self):\n        if self._running:\n            return\n        self._running = True\n        self._thread = threading.Thread(target=self._run)\n        self._thread.daemon = True\n        self._thread.start()\n\n    def stop(self):\n        self._running = False\n        if self._thread:\n            self._thread.join()\n\n    def _run(self):\n        while self._running:\n            self._process_once()\n</code></pre>"},{"location":"development_rules/#api-design-principles","title":"API Design Principles","text":"<ul> <li>Provide both simple and advanced interfaces</li> <li>Use context managers for resource management</li> <li>Support both synchronous and asynchronous patterns when appropriate</li> <li>Follow the principle of least surprise</li> </ul>"},{"location":"api/cam/","title":"senxor.cam","text":""},{"location":"api/cam/#senxorcam","title":"<code>senxor.cam</code>","text":"<p>RGB camera related utilities.</p>"},{"location":"api/cam/#senxor.cam.list_camera","title":"<code>list_camera()</code>","text":"<p>List all cameras available.</p> Warning: <p>This function is deprecated. Use <code>list_camera_info</code> instead.</p> Returns: <p>list[str]     A list of camera names.</p> Examples: <p>list_camera() ['Camera 0', 'Camera 1', 'Camera 2']</p> <p>You can use <code>cv2.VideoCapture(index)</code> to open a camera.</p>"},{"location":"api/cam/#senxor.cam.list_camera_info","title":"<code>list_camera_info(backend=0)</code>","text":"<p>List available camera information.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>int</code> <p>The backend to use for camera enumeration. If 0, all supported backends are used.</p> <code>0</code> <p>Returns:</p> Type Description <code>list of CameraInfo</code> <p>List of camera information objects. Use <code>cv2.VideoCapture(camera.index, camera.backend)</code> to open a camera.</p> <p>Examples:</p> <ol> <li>Print all cameras information available.</li> </ol> <pre><code>&gt;&gt;&gt; for camera in list_camera_info():\n...     print(camera.index, camera.name, camera.backend)\n...     print(camera.path, camera.vid, camera.pid)\n</code></pre> <ol> <li>Connect to a specific camera.</li> </ol> <pre><code>&gt;&gt;&gt; camera_info = list_camera_info()[0]\n&gt;&gt;&gt; cap = cv2.VideoCapture(camera_info.index, camera_info.backend)\n</code></pre>"},{"location":"api/consts/","title":"senxor.consts","text":""},{"location":"api/consts/#senxorconsts","title":"<code>senxor.consts</code>","text":"<p>Constants related to Senxor devices.</p>"},{"location":"api/log/","title":"senxor.log","text":""},{"location":"api/log/#senxorlog","title":"<code>senxor.log</code>","text":"<p>Logging utilities for Senxor devices.</p>"},{"location":"api/log/#senxor.log.get_logger","title":"<code>get_logger(logger_name='senxor', *args, **kwargs)</code>","text":"<p>Get a structured logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>logger_name</code> <code>str</code> <p>The name of the logger, by default <code>\"senxor\"</code></p> <code>'senxor'</code> <code>*args</code> <code>Any</code> <p>Positional arguments to pass to <code>structlog.get_logger</code>.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to <code>structlog.get_logger</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>SenxorLogger</code> <p>A structured logger instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from senxor.log import get_logger\n&gt;&gt;&gt; logger = get_logger(device_id=\"1\")\n&gt;&gt;&gt; logger.warning(\"This is a warning message.\")\n[warning  ] This is a warning message.    device_id=1\n</code></pre>"},{"location":"api/log/#senxor.log.setup_console_logger","title":"<code>setup_console_logger(log_level='INFO', logger_name='senxor', *, add_logger_name=False)</code>","text":"<p>Setup a console logger.</p> <p>This logger is used to log messages to the console, can output colored and formatted messages.</p> <p>Parameters:</p> Name Type Description Default <code>log_level</code> <code>int | str | None</code> <p>The log level to use, by default <code>logging.INFO</code></p> <code>'INFO'</code> <code>logger_name</code> <code>str</code> <p>The name of the logger, by default <code>\"senxor\"</code></p> <code>'senxor'</code> <code>add_logger_name</code> <code>bool</code> <p>Whether to add the logger name to the console output, by default <code>False</code></p> <code>False</code>"},{"location":"api/log/#senxor.log.setup_file_logger","title":"<code>setup_file_logger(file_path, file_mode='w', log_level='INFO', logger_name='senxor', *, watch_file=False, json_format=False)</code>","text":"<p>Setup a file logger.</p> <p>This logger is used to log messages to a file, can output formatted messages.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>The path to the log file.</p> required <code>file_mode</code> <code>str</code> <p>The mode to use for the log file, by default <code>\"w\"</code></p> <code>'w'</code> <code>log_level</code> <code>int | str</code> <p>The log level to use, by default <code>logging.INFO</code></p> <code>'INFO'</code> <code>logger_name</code> <code>str</code> <p>The name of the logger, by default <code>\"senxor\"</code></p> <code>'senxor'</code> <code>watch_file</code> <code>bool</code> <p>Whether to use the <code>logging.handlers.WatchedFileHandler</code> handler, by default <code>False</code></p> <code>False</code> <code>json_format</code> <code>bool</code> <p>Whether to use the <code>structlog.processors.JSONRenderer</code> formatter, by default <code>False</code></p> <code>False</code>"},{"location":"api/log/#senxor.log.setup_standard_logger","title":"<code>setup_standard_logger()</code>","text":"<p>Setup a standard logger.</p> <p>This logger redirects all messages to the built-in <code>logging</code> module. It is the default logger for <code>senxor</code>. This logger is used by default when <code>senxor</code> is used as a library, which means that <code>senxor</code> should not have any side effects on the logging system.</p> <p>Instead, use <code>setup_console_logger</code> or <code>setup_file_logger</code> to setup a logger for your application.</p>"},{"location":"api/proc/","title":"senxor.proc","text":""},{"location":"api/proc/#senxorproc","title":"<code>senxor.proc</code>","text":"<p>Image processing utilities for Senxor devices.</p>"},{"location":"api/proc/#senxor.proc.apply_colormap","title":"<code>apply_colormap(image, lut, in_range=None, to_int=True, resample_size=256, norm=False)</code>","text":"<p>Apply a colormap to a grayscale image using numpy. Return a uint8/float32 RGB image, depending on the <code>to_int</code>.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>The image to apply the colormap to. Should be a 2D array.</p> required <code>lut</code> <code>ndarray</code> <p>The colormap to apply. Should be a 2D array of shape (N, 3) or (N, 1, 3).</p> required <code>in_range</code> <code>tuple | None</code> <p>The input range of the image. If <code>None</code>, the image's min/max are used. providing (min, max) is recommended, because this can avoid re-computation.</p> <code>None</code> <code>to_int</code> <code>bool</code> <p>If True, the color image will be converted to uint8 after applying the colormap. If False and image.dtype is not uint8, the color image will be normalized to float32.</p> <code>True</code> <code>resample_size</code> <code>int</code> <p>The colormap will be resampled to this size. For image formats with more detail, such as float32, increasing <code>resample_size</code> can help preserve more of the original image's fidelity. However, the actual effectiveness depends on the characteristics of the input image. Default is 256.</p> <code>256</code> <code>norm</code> <code>bool</code> <p>Whether to normalize the image before applying the colormap. Default is False.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; image = np.array([[0, 100, 200], [50, 150, 255]], dtype=np.uint8)\n&gt;&gt;&gt; lut = get_colormaps(\"viridis\", namespace=\"cv\", n=256)\n&gt;&gt;&gt; color_image = apply_colormap(image, lut)\n&gt;&gt;&gt; print(color_image.dtype)\nuint8\n</code></pre> <pre><code>&gt;&gt;&gt; image = np.array([[0, 100, 200], [50, 150, 255]], dtype=np.float32)\n&gt;&gt;&gt; lut = get_colormaps(\"viridis\", namespace=\"cv\", n=256)\n&gt;&gt;&gt; color_image = apply_colormap(image, lut, to_int=False)\n&gt;&gt;&gt; print(color_image.dtype)\nfloat32\n</code></pre>"},{"location":"api/proc/#senxor.proc.bytes_to_adc","title":"<code>bytes_to_adc(bytes_data)</code>","text":"<p>Convert bytes data to ADC data.</p>"},{"location":"api/proc/#senxor.proc.bytes_to_raw","title":"<code>bytes_to_raw(bytes_data, unit)</code>","text":"<p>Convert bytes data to raw data.</p>"},{"location":"api/proc/#senxor.proc.dk_to_celsius","title":"<code>dk_to_celsius(raw)</code>","text":"<p>Convert raw data from <code>Senxor.read()</code> to Celsius degrees data.</p> <p>The senxor device returns data in uint16 format, which is 1/10 Kelvin. This function converts the data to Celsius degrees.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>ndarray</code> <p>The raw data.</p> required"},{"location":"api/proc/#senxor.proc.enlarge","title":"<code>enlarge(image, scale)</code>","text":"<p>Enlarge an image by an integer scale factor using nearest neighbor (no interpolation).</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Input image array (2D or 3D).</p> required <code>scale</code> <code>int</code> <p>Integer scale factor for enlargement (must be &gt;= 1).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Enlarged image array.</p>"},{"location":"api/proc/#senxor.proc.normalize","title":"<code>normalize(image, in_range=None, out_range=None, dtype=np.float32)</code>","text":"<p>Normalize image intensity to a desired range and data type using NumPy.</p> <p>Supported dtypes:</p> <ul> <li><code>np.floating</code></li> <li><code>np.uint8</code></li> <li><code>np.uint16</code></li> <li><code>np.int16</code></li> <li><code>np.int32</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Input image.</p> required <code>in_range</code> <code>tuple or None</code> <p>Min and max intensity values of the input image. If None, the min and max of the input image are used. Default is None. Providing (min, max) is recommended, because this can avoid re-computation.</p> <code>None</code> <code>out_range</code> <code>tuple or None</code> <p>Min and max intensity values of the output image.</p> <p>The function does not validate the <code>out_range</code> parameter if it is specified, be careful.</p> <p>If None:</p> <ul> <li>If <code>dtype</code> is specified as a floating-point type, (0.0, 1.0) is used.</li> <li>If <code>dtype</code> is specified as an integer type, the min/max of <code>dtype</code> are used.</li> <li>If <code>dtype</code> is None:<ul> <li>If image.dtype is a floating-point type, (0.0, 1.0) is used.</li> <li>If image.dtype is an integer type, the min/max of image.dtype are used. Default is None.</li> </ul> </li> </ul> <code>None</code> <code>dtype</code> <code>dtype or None</code> <p>Desired output data type. If None, the input image's data type is used. Default is np.float32.</p> <code>float32</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized image with the specified range and data type.</p> <p>Examples:</p> <p>This function normalizes any image or numerical array, scaling its intensity values to a desired output range and data type.</p> <ol> <li>Normalizing a float array to an 8-bit image (0 to 255):</li> </ol> <pre><code>&gt;&gt;&gt; data_float = np.array([[-0.5, 0.0, 0.5], [1.0, 1.5, 2.0]], dtype=np.float32)\n&gt;&gt;&gt; print(data_float)\n    [[-0.5  0.   0.5]\n    [ 1.   1.5  2. ]]\n&gt;&gt;&gt; normalized_uint8 = normalize(data_float, dtype=np.uint8)\n&gt;&gt;&gt; print(normalized_uint8)\n    [[  0  64 127]\n    [191 255 255]]\n&gt;&gt;&gt; print(normalized_uint8.dtype)\nuint8\n</code></pre> <ol> <li>Normalizing an 8-bit image to float (0.0 to 1.0):</li> </ol> <pre><code>&gt;&gt;&gt; image_uint8 = np.array([[0, 100, 200], [50, 150, 255]], dtype=np.uint8)\n&gt;&gt;&gt; print(image_uint8)\n    [[  0 100 200]\n    [ 50 150 255]]\n&gt;&gt;&gt; normalized_float = normalize(image_uint8, dtype=np.float32)\n&gt;&gt;&gt; print(normalized_float)\n    [[0.   0.39215686 0.78431373]\n    [0.19607843 0.58823529 1.        ]]\n&gt;&gt;&gt; print(normalized_float.dtype)\nfloat32\n</code></pre> <ol> <li>If the min/max value of in_range is more/less than the min/max image intensity, then the intensity levels are clipped:</li> </ol> <pre><code>&gt;&gt;&gt; image = np.array([51, 102, 153], dtype=np.float32)\n&gt;&gt;&gt; normalize(image, in_range=(0, 255))\narray([0.2, 0.4, 0.6], dtype=float32)\n</code></pre> Notes <ol> <li>Avoiding re-computation: If you've already computed min/max, provide them via <code>in_range</code> to avoid re-computation.</li> <li>Preserving original contrast: To prevent stretching, set <code>in_range</code> to the original data's known intensity bounds or full <code>dtype</code> range.</li> <li>Maintaining precision: For multi-step processing, use floating-point types (<code>np.float32</code>/<code>np.float64</code>) for intermediate steps. Only normalize to <code>np.uint8</code> as the very last step for display or saving.</li> </ol>"},{"location":"api/proc/#senxor.proc.raw_to_frame","title":"<code>raw_to_frame(raw)</code>","text":"<p>Convert the raw data from <code>Senxor.read(..., raw=True)</code> to a shaped frame.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>ndarray</code> <p>The raw data from <code>Senxor.read(..., raw=True)</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The shaped frame.</p>"},{"location":"api/proc/#senxor.proc.raw_to_temp","title":"<code>raw_to_temp(raw, in_unit, out_unit)</code>","text":"<p>Convert raw data to temperature data.</p>"},{"location":"api/regmap/","title":"senxor.regmap","text":""},{"location":"api/regmap/#senxorregmap","title":"<code>senxor.regmap</code>","text":""},{"location":"api/regmap/#senxor.regmap.Field","title":"<code>Field</code>","text":"<p>Field instance.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the field.</p> <code>group</code> <code>str</code> <p>The register group that the field belongs to.</p> <code>readable</code> <code>bool</code> <p>Whether the field is readable.</p> <code>writable</code> <code>bool</code> <p>Whether the field is writable.</p> <code>type</code> <code>str</code> <p>The type of the field.</p> <code>desc</code> <code>str</code> <p>The description of the field.</p> <code>help</code> <code>str</code> <p>The help of the field.</p> <code>value</code> <code>int</code> <p>The integer value of the field.</p> <code>display</code> <code>str</code> <p>The display value of the field, which is the value formatted for display.</p>"},{"location":"api/regmap/#senxor.regmap.Field.value","title":"<code>value</code>  <code>property</code>","text":"<p>Return the current value of the field (alias of get).</p>"},{"location":"api/regmap/#senxor.regmap.Field.__init__","title":"<code>__init__(descriptor, instance)</code>","text":"<p>Initialize the field instance.</p> <p>Note: Do not initialize this class directly, this class is designed to be used as a Descriptor Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>descriptor</code> <code>_FieldDescriptor</code> <p>The field descriptor.</p> required <code>instance</code> <code>Fields</code> <p>The instance of the field.</p> required"},{"location":"api/regmap/#senxor.regmap.Field.display","title":"<code>display(value=None)</code>","text":"<p>Return the display value of the field.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int | None</code> <p>The value to display. If None, will try to get the current value of the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The display value of the field.</p>"},{"location":"api/regmap/#senxor.regmap.Field.get","title":"<code>get()</code>","text":"<p>Return current integer value of this field.</p>"},{"location":"api/regmap/#senxor.regmap.Field.set","title":"<code>set(value)</code>","text":"<p>Write value to field after validation.</p>"},{"location":"api/regmap/#senxor.regmap.Field.validate","title":"<code>validate(value)</code>","text":"<p>Validate value using custom validator if present.</p>"},{"location":"api/regmap/#senxor.regmap.Fields","title":"<code>Fields</code>","text":""},{"location":"api/regmap/#senxor.regmap.Fields.fields","title":"<code>fields</code>  <code>property</code>","text":"<p>Return a dict of all field instances.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.readable_fields","title":"<code>readable_fields</code>  <code>property</code>","text":"<p>Return a set of all readable field names.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.status","title":"<code>status</code>  <code>property</code>","text":"<p>Return a dictionary of all field values after last operation.</p> <p>Note: Due to some fields can be auto-reset, this may not reflect the current device state.</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>The dictionary of field names and their values.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.status_display","title":"<code>status_display</code>  <code>property</code>","text":"<p>Return a dictionary of all field names and human-readable representations of last status.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.writable_fields","title":"<code>writable_fields</code>  <code>property</code>","text":"<p>Return a set of all writable field names.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get a field instance by name.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.get_field","title":"<code>get_field(field)</code>","text":"<p>Return the integer value of a field.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str | Field</code> <p>Field name (e.g. <code>\"FRAME_RATE_DIVIDER\"</code>) or Field instance.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The integer value of the field.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.get_fields","title":"<code>get_fields(fields)</code>","text":"<p>Get multiple field values.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.set_field","title":"<code>set_field(field, value)</code>","text":"<p>Set a field value.</p>"},{"location":"api/regmap/#senxor.regmap.Fields.set_fields","title":"<code>set_fields(fields_values)</code>","text":"<p>Set multiple field values.</p>"},{"location":"api/regmap/#senxor.regmap.Register","title":"<code>Register</code>","text":""},{"location":"api/regmap/#senxor.regmap.Register.value","title":"<code>value</code>  <code>property</code>","text":"<p>The value of the register.</p>"},{"location":"api/regmap/#senxor.regmap.Register.__init__","title":"<code>__init__(descriptor, instance)</code>","text":"<p>Initialize the register instance.</p> <p>Note: Do not initialize this class directly, this class is designed to be used as a Descriptor Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>descriptor</code> <code>_RegisterDescriptor</code> <p>The register descriptor.</p> required <code>instance</code> <code>Registers</code> <p>The instance of the register.</p> required"},{"location":"api/regmap/#senxor.regmap.Register.get","title":"<code>get()</code>","text":"<p>Get the value of the register.</p>"},{"location":"api/regmap/#senxor.regmap.Register.read","title":"<code>read()</code>","text":"<p>Read the value of the register.</p>"},{"location":"api/regmap/#senxor.regmap.Register.set","title":"<code>set(value)</code>","text":"<p>Set the value of the register.</p>"},{"location":"api/regmap/#senxor.regmap.Registers","title":"<code>Registers</code>","text":""},{"location":"api/regmap/#senxor.regmap.Registers.readable_regs","title":"<code>readable_regs</code>  <code>property</code>","text":"<p>Return a set of all readable register names.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.regs","title":"<code>regs</code>  <code>property</code>","text":"<p>Return a dictionary of all register instances.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.status","title":"<code>status</code>  <code>property</code>","text":"<p>Return a dictionary of all register values after last operation.</p> <p>Note: Due to some registers can be auto-reset, this may not reflect the current device state.</p> <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>The dictionary of register addresses and their values.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.writable_regs","title":"<code>writable_regs</code>  <code>property</code>","text":"<p>Return a set of all writable register names.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.get_addr","title":"<code>get_addr(key)</code>","text":"<p>Get the address of a register.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | int | Register</code> <p>The key of the register.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The address of the register.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.get_reg","title":"<code>get_reg(addr)</code>","text":"<p>Get a register value by address.</p> <p>This method try to use the cached value instead of reading from the device if possible.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.get_regs","title":"<code>get_regs(addrs)</code>","text":"<p>Get multiple register values by addresses.</p> <p>This method try to use the cached value instead of reading from the device if possible.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.read_all","title":"<code>read_all()</code>","text":"<p>Read all registers from the device.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.read_reg","title":"<code>read_reg(addr)</code>","text":"<p>Read a single register from the device.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.read_regs","title":"<code>read_regs(addrs)</code>","text":"<p>Read multiple registers from the device.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.write_reg","title":"<code>write_reg(addr, value)</code>","text":"<p>Write a single register to the device.</p>"},{"location":"api/regmap/#senxor.regmap.Registers.write_regs","title":"<code>write_regs(values_dict)</code>","text":"<p>Write multiple registers to the device.</p>"},{"location":"api/senxor/","title":"senxor","text":""},{"location":"api/senxor/#senxor_1","title":"<code>senxor</code>","text":"<p>Top-level package for Senxor devices.</p>"},{"location":"api/senxor/#senxor.Senxor","title":"<code>Senxor</code>","text":""},{"location":"api/senxor/#senxor.Senxor.__init__","title":"<code>__init__(address, interface_type=None, *, auto_open=True, read_temp_units='C', **kwargs)</code>","text":"<p>Initialize the senxor.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>Any</code> <p>The address of the senxor.</p> required <code>interface_type</code> <code>Literal['serial'] | None</code> <p>The type of the interface, by default None.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>Whether to open the senxor automatically, by default True.</p> <code>True</code> <code>read_temp_units</code> <code>Literal['K', 'C', 'F']</code> <p>The temperature units to use for the <code>read</code> method, by default \"C\".</p> <code>'C'</code> <code>kwargs</code> <code>Any</code> <p>The extra keyword arguments for the interface.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the address is not valid for any of the supported types.</p>"},{"location":"api/senxor/#senxor.Senxor.close","title":"<code>close()</code>","text":"<p>Close the senxor. If the senxor is not connected, do nothing.</p>"},{"location":"api/senxor/#senxor.Senxor.get_fw_version","title":"<code>get_fw_version()</code>","text":"<p>Get the firmware version string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The firmware version string.</p>"},{"location":"api/senxor/#senxor.Senxor.get_module_category","title":"<code>get_module_category()</code>","text":"<p>Get the module category.</p>"},{"location":"api/senxor/#senxor.Senxor.get_module_type","title":"<code>get_module_type()</code>","text":"<p>Get the module type.</p>"},{"location":"api/senxor/#senxor.Senxor.get_production_year","title":"<code>get_production_year()</code>","text":"<p>Get the production year.</p> <p>Returns:</p> Type Description <code>int</code> <p>The production year.</p>"},{"location":"api/senxor/#senxor.Senxor.get_senxor_id_hex","title":"<code>get_senxor_id_hex()</code>","text":"<p>Get the senxor id(SN code) string in hex format.</p> <p>The senxor id is a hex string of 12 characters, the format is: <code>YYWWLLSSSSSS</code>, where: - <code>YY</code> is the production year (from 2000 to 2099). - <code>WW</code> is the production week. - <code>LL</code> is the manufacturing location. - <code>SSSSSS</code> is the serial number (from 000000 to 999999).</p> <p>Returns:</p> Type Description <code>str</code> <p>The senxor id.</p>"},{"location":"api/senxor/#senxor.Senxor.get_shape","title":"<code>get_shape()</code>","text":"<p>Get the frame shape(height, width) of the senxor.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The frame shape(height, width) of the senxor.</p>"},{"location":"api/senxor/#senxor.Senxor.get_sn","title":"<code>get_sn()</code>","text":"<p>Get the SN code string. Same as <code>get_senxor_id_hex</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>The SN code string.</p>"},{"location":"api/senxor/#senxor.Senxor.get_temp_units","title":"<code>get_temp_units()</code>","text":"<p>Get the temperature units configured on the device.</p> <p>The temperature units of the frame is determined by two fields: <code>ADC_ENABLE</code> and <code>TEMP_UNITS</code>. If <code>ADC_ENABLE</code> is set to <code>1</code>, the temperature units is <code>adc</code>. Otherwise, the temperature units is determined by <code>TEMP_UNITS</code>.</p> <p>For Panther Module, the temperature units is always <code>dK</code> whatever the <code>TEMP_UNITS</code> field is.</p> <p>Note: The <code>read</code> method may convert temperature units based on input parameters and may not follow the device's configuration.</p> <p>Returns:</p> Type Description <code>Literal['dK', 'dC', 'dF', 'K', 'C', 'F', 'adc']</code> <p>The temperature units of the frame. - <code>dK</code>: 0.1 K - <code>dC</code>: 0.1 \u00b0C - <code>dF</code>: 0.1 \u00b0F - <code>K</code>: 1 K - <code>C</code>: 1 \u00b0C - <code>F</code>: 1 \u00b0F - <code>adc</code>: ADC data(uint16)</p>"},{"location":"api/senxor/#senxor.Senxor.open","title":"<code>open()</code>","text":"<p>Open the senxor. If the senxor is already connected, do nothing.</p>"},{"location":"api/senxor/#senxor.Senxor.read","title":"<code>read(*, block=True, raw=False, celsius=None)</code>","text":"<pre><code>read(\n    *, raw: bool = False, celsius: bool | None = None\n) -&gt; tuple[np.ndarray | None, np.ndarray]\n</code></pre><pre><code>read(\n    *,\n    block: Literal[False],\n    raw: bool = False,\n    celsius: bool | None = None,\n) -&gt; tuple[np.ndarray | None, np.ndarray | None]\n</code></pre><pre><code>read(\n    *,\n    block: Literal[True] = True,\n    raw: bool = False,\n    celsius: bool | None = None,\n) -&gt; tuple[np.ndarray | None, np.ndarray]\n</code></pre> <p>Read the frame data from the senxor, return (header: np.ndarray[uint16], frame: np.ndarray).</p> <p>The header is a 1D numpy array of uint16, check documentation for more details. The frame depends on the <code>raw</code> and <code>celsius</code> parameters. By default, the frame is a numpy array with shape (height, width), dtype is float32, each element means the temperature in Celsius.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>bool</code> <p>Whether to block the read operation until a frame is available. If False, if no frame is available, return None immediately.</p> <code>True</code> <code>raw</code> <code>bool</code> <p>Whether to return the raw data or the frame data. Raw data is a flat numpy array of uint16. Frame data is reshaped to a 2D numpy array of uint16. In the most cases, frame data is open to use.</p> <code>False</code> <code>celsius</code> <code>bool</code> <p>Whether to convert the frame data to Celsius. If True, the frame data will be converted to Celsius, float32. If False, the frame data will be returned in 1/10 Kelvin, uint16.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[ndarray | None, ndarray | None]</code> <p>The frame data, as a tuple of two numpy arrays. The first array is the header data, the second array is the frame data.</p> <p>If <code>block=False</code> and no frame is available, return (None, None).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the senxor is not in the stream mode or single capture mode.</p> <code>SenxorAckTimeoutError</code> <p>If the read operation timeout due to other reasons.</p>"},{"location":"api/senxor/#senxor.Senxor.read_reg","title":"<code>read_reg(reg)</code>","text":"<p>Read the value from a register.</p> Notes <ul> <li>You need to know the register name or address to use this method.</li> <li>For a more modern and editor-friendly approach, use <code>senxor.regs.REG_NAME</code> to benefit from autocompletion.</li> <li>If you want to read multiple registers at once, <code>read_regs</code> is more efficient as it only communicates with the device once.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>reg</code> <code>int | str | Register</code> <p>The register to read from, specified as a Register instance, a register name, or an integer address.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value read from the register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register is not readable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; senxor.read_reg(senxor.regs.EMISSIVITY)\n95\n&gt;&gt;&gt; senxor.read_reg(\"EMISSIVITY\")\n95\n&gt;&gt;&gt; senxor.read_reg(0xCA)\n95\n&gt;&gt;&gt; senxor.read_reg(202)\n95\n</code></pre>"},{"location":"api/senxor/#senxor.Senxor.read_regs","title":"<code>read_regs(regs)</code>","text":"<p>Read the values from multiple registers at once.</p> <p>Note: This method takes the almost same time as reading one register.</p> <p>Parameters:</p> Name Type Description Default <code>regs</code> <code>list[str | int | Register]</code> <p>The list of registers to read from, specified as a list of register names, integer addresses, or Register instances.</p> required <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>The dictionary of register addresses and their values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a register is not readable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; senxor.regs_read([0xB1, 0xB2, 0xB3, 0xB4])\n{177: 0, 178: 0, 179: 0, 180: 0}\n</code></pre>"},{"location":"api/senxor/#senxor.Senxor.refresh_regmap","title":"<code>refresh_regmap()</code>","text":"<p>Refresh the regmap cache. This method will read all registers and update all fields.</p> <p>Then use <code>self.regs.status</code> and <code>self.fields.status</code> to get the status you want.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; senxor.refresh_regmap()\n&gt;&gt;&gt; senxor.regs.status\n{177: 0, 0: 0, 1: 0, ...}\n&gt;&gt;&gt; senxor.fields.status\n{\"SW_RESET\": 0, \"DMA_TIMEOUT_ENABLE\": 0, ...}\n</code></pre>"},{"location":"api/senxor/#senxor.Senxor.set_read_temp_units","title":"<code>set_read_temp_units(temp_units)</code>","text":"<p>Set the temperature units to use for the <code>read</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>temp_units</code> <code>Literal['K', 'C', 'F']</code> <p>The temperature units to use for the <code>read</code> method.</p> required"},{"location":"api/senxor/#senxor.Senxor.start_stream","title":"<code>start_stream()</code>","text":"<p>Start the stream mode.</p>"},{"location":"api/senxor/#senxor.Senxor.stop_stream","title":"<code>stop_stream()</code>","text":"<p>Stop the stream mode.</p>"},{"location":"api/senxor/#senxor.Senxor.write_reg","title":"<code>write_reg(reg, value)</code>","text":"<p>Write a value to a register.</p> <p>Parameters:</p> Name Type Description Default <code>reg</code> <code>str | int | Register</code> <p>The register to write to, specified as a register name, integer address, or Register instance.</p> required <code>value</code> <code>int</code> <p>The value to write to the register (0-0xFF).</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The result of the write operation, as returned by the interface.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register is not writable or the value is out of range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; senxor.write_reg(\"EMISSIVITY\", 0x5F)\n&gt;&gt;&gt; senxor.write_reg(0xCA, 0x5F)\n&gt;&gt;&gt; senxor.write_reg(senxor.regs.EMISSIVITY, 0x5F)\n</code></pre>"},{"location":"api/senxor/#senxor.connect","title":"<code>connect(address=None, type=None, *, auto_open=True, stop_stream=True, **kwargs)</code>","text":"<p>Connect to a Senxor device.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str | ListPortInfo</code> <p>The address of the device to connect to.</p> <code>None</code> <code>type</code> <code>Literal['serial']</code> <p>The type of device to connect to. If not provided, will attempt to auto-detect from address.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>Whether to automatically open the device.</p> <code>True</code> <code>stop_stream</code> <code>(bool, optional(deprecated))</code> <p>Whether to stop the stream when the device is opened. .. deprecated:: 3.1.0     This parameter is deprecated and will be removed in future versions.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to the interface constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Senxor</code> <p>The Senxor device.</p> <p>Examples:</p> <p>Use a context manager to connect to a device:</p> <pre><code>&gt;&gt;&gt; from senxor import list_senxor, connect\n&gt;&gt;&gt; addrs = list_senxor(\"serial\")\n&gt;&gt;&gt; with connect(addrs[0]) as dev:\n...     print(f\"Connected to device {dev.address}\")\nConnected to device COM3\n</code></pre> <p>Or connect to a device without a context manager:</p> <pre><code>&gt;&gt;&gt; dev = connect(addrs[0])\n&gt;&gt;&gt; print(f\"Connected to device {dev.address}\")\nConnected to device COM3\n</code></pre> <p>It's recommended to use a context manager because it will automatically close the device when the context is exited.</p>"},{"location":"api/senxor/#senxor.list_senxor","title":"<code>list_senxor(type=None, exclude=None)</code>","text":"<p>List all Senxor devices available.</p> <p>The return value is a list of Senxor devices, use <code>senxor.connect</code> to connect to a device.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['serial'] | None</code> <p>The type of device to list. If not provided, all types will be listed.</p> <code>None</code> <code>exclude</code> <code>list[str] | str | None</code> <p>If <code>type</code> is provided, this will be ignored. A list of device names to exclude from the list. If not provided, all devices will be listed.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of Senxor devices, use <code>senxor.connect</code> to connect to a device.</p>"},{"location":"api/settings/","title":"senxor.settings","text":""},{"location":"api/settings/#senxorsettings","title":"<code>senxor.settings</code>","text":""},{"location":"api/settings/#senxor.settings.apply","title":"<code>apply(senxor, settings)</code>","text":"<p>Apply settings to a Senxor object from either a dictionary of profiles or a file path.</p> <p>Parameters:</p> Name Type Description Default <code>senxor</code> <code>Senxor</code> <p>The Senxor object to which the settings will be applied.</p> required <code>settings</code> <code>dict[str, Profile] or Profile or str or Path</code> <p>A file path to load settings from, or a dictionary of profiles, or a single profile.</p> required <p>Examples:</p> <ol> <li>Apply settings from a file path:</li> </ol> <pre><code>&gt;&gt;&gt; apply(senxor, \"settings.yaml\")\n</code></pre> <ol> <li>Apply settings from a dictionary of profiles:</li> </ol> <pre><code>&gt;&gt;&gt; settings = load(\"settings.yaml\")\n&gt;&gt;&gt; apply(senxor, settings)\n</code></pre> <ol> <li>Apply a single profile:</li> </ol> <pre><code>&gt;&gt;&gt; profile = load(\"settings.yaml\")[\"default\"]\n&gt;&gt;&gt; apply(senxor, profile)\n</code></pre>"},{"location":"api/settings/#senxor.settings.load","title":"<code>load(path)</code>","text":"<p>Load settings from a specified file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>The file path to load settings from. Supports YAML, TOML, and JSON formats.</p> required <p>Returns:</p> Type Description <code>dict[str, Profile]</code> <p>A dictionary of profiles loaded from the file, where each key is the profile name and the value is a <code>Profile</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; settings = load(\"settings.yaml\")\n&gt;&gt;&gt; default_setting = settings[\"default\"]\n&gt;&gt;&gt; default_setting.name\n'default'\n&gt;&gt;&gt; default_setting.settings\n{'foo': 1, 'bar': 2}\n&gt;&gt;&gt; default_setting.when\n'foo &gt; 10 and bar &lt; 20'\n</code></pre>"},{"location":"api/settings/#senxor.settings.loads","title":"<code>loads(fp, filetype='yaml')</code>","text":"<p>Load settings from a file-like object or string, specifying the file type.</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>file-like object or str or bytes</code> <p>A file-like object with a <code>.read()</code> method or a string/bytes containing the settings data.</p> required <code>filetype</code> <code>Literal['yaml', 'toml', 'json']</code> <p>The file type to parse ('yaml', 'toml', or 'json'). Default is 'yaml'.</p> <code>'yaml'</code> <p>Returns:</p> Type Description <code>dict[str, Profile]</code> <p>A dictionary of profiles loaded from the input, where each key is the profile name and the value is a <code>Profile</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"settings.yaml\", \"r\") as f:\n...     settings = loads(f, filetype=\"yaml\")\n</code></pre>"},{"location":"api/thread/","title":"senxor.thread","text":""},{"location":"api/thread/#senxorthread","title":"<code>senxor.thread</code>","text":"<p>Thread utilities for Senxor devices.</p>"},{"location":"api/thread/#senxor.thread.CVCamThread","title":"<code>CVCamThread</code>","text":""},{"location":"api/thread/#senxor.thread.CVCamThread.__init__","title":"<code>__init__(video_capture, on_data=None, *, raise_on_backlog=False, backlog_threshold=5)</code>","text":"<p>Thread for reading frames from a video capture.</p> <p>Parameters:</p> Name Type Description Default <code>video_capture</code> <code>VideoCapture</code> <p>The video capture to read frames from.</p> required <code>on_data</code> <code>Callable</code> <p>The callback function to call when a frame is read.</p> <code>None</code> <code>raise_on_backlog</code> <code>bool</code> <p>Whether to raise an error if the frame buffer backlog exceeds the threshold.</p> <code>False</code> <code>backlog_threshold</code> <code>int</code> <p>The threshold for the frame buffer backlog.</p> <code>5</code>"},{"location":"api/thread/#senxor.thread.CVCamThread.read","title":"<code>read()</code>","text":"<p>Read the frame from the video capture.</p> <p>Returns:</p> Type Description <code>ndarray | None</code> <p>The frame from the video capture.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the thread is not started.</p>"},{"location":"api/thread/#senxor.thread.SenxorThread","title":"<code>SenxorThread</code>","text":""},{"location":"api/thread/#senxor.thread.SenxorThread.__init__","title":"<code>__init__(senxor, on_data=None, *, raise_on_backlog=False, backlog_threshold=5)</code>","text":"<p>Thread for reading data from a Senxor device.</p> <p>Parameters:</p> Name Type Description Default <code>senxor</code> <code>Senxor</code> <p>The Senxor device to read data from.</p> required <code>on_data</code> <code>Callable</code> <p>The callback function to call when a frame is read.</p> <code>None</code> <code>raise_on_backlog</code> <code>bool</code> <p>Whether to raise an error if the data buffer backlog exceeds the threshold.</p> <code>False</code> <code>backlog_threshold</code> <code>int</code> <p>The threshold for the data buffer backlog.</p> <code>5</code>"},{"location":"api/thread/#senxor.thread.SenxorThread.read","title":"<code>read()</code>","text":"<p>Read the data from the Senxor device.</p> <p>It's equivalent to <code>senxor.read(block=False)</code>, if you don't need the <code>on_data</code> callback, it's not necessary to use <code>SenxorThread</code>.</p> <p>Returns:</p> Type Description <code>tuple[ndarray | None, ndarray | None]</code> <p>The (header, data) from the Senxor device.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the thread is not started.</p>"},{"location":"api/utils/","title":"senxor.utils","text":""},{"location":"api/utils/#senxorutils","title":"<code>senxor.utils</code>","text":"<p>Utilities for Senxor devices.</p>"},{"location":"api/utils/#senxor.utils.connect","title":"<code>connect(address=None, type=None, *, auto_open=True, stop_stream=True, **kwargs)</code>","text":"<p>Connect to a Senxor device.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str | ListPortInfo</code> <p>The address of the device to connect to.</p> <code>None</code> <code>type</code> <code>Literal['serial']</code> <p>The type of device to connect to. If not provided, will attempt to auto-detect from address.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>Whether to automatically open the device.</p> <code>True</code> <code>stop_stream</code> <code>(bool, optional(deprecated))</code> <p>Whether to stop the stream when the device is opened. .. deprecated:: 3.1.0     This parameter is deprecated and will be removed in future versions.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to the interface constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Senxor</code> <p>The Senxor device.</p> <p>Examples:</p> <p>Use a context manager to connect to a device:</p> <pre><code>&gt;&gt;&gt; from senxor import list_senxor, connect\n&gt;&gt;&gt; addrs = list_senxor(\"serial\")\n&gt;&gt;&gt; with connect(addrs[0]) as dev:\n...     print(f\"Connected to device {dev.address}\")\nConnected to device COM3\n</code></pre> <p>Or connect to a device without a context manager:</p> <pre><code>&gt;&gt;&gt; dev = connect(addrs[0])\n&gt;&gt;&gt; print(f\"Connected to device {dev.address}\")\nConnected to device COM3\n</code></pre> <p>It's recommended to use a context manager because it will automatically close the device when the context is exited.</p>"},{"location":"api/utils/#senxor.utils.data_to_frame","title":"<code>data_to_frame(data, array_shape=None, *, hflip=False)</code>","text":"<p>Convert raw data to a frame.</p> <p>It's used for backward compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>The raw data.</p> required <code>array_shape</code> <code>tuple[int, int] | None</code> <p>Not needed, it's for backward compatibility.</p> <code>None</code> <code>hflip</code> <code>bool</code> <p>Whether to flip the image horizontally.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The frame.</p>"},{"location":"api/utils/#senxor.utils.is_senxor_usb","title":"<code>is_senxor_usb(port)</code>","text":"<p>Check if the port is a senxor port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>ListPortInfo | str</code> <p>The port to check. Use <code>list_ports.comports()</code> to get the list of ports.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the port is a senxor port, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ports = list_ports.comports()\n&gt;&gt;&gt; for port in ports:\n&gt;&gt;&gt;     if is_senxor_port(port):\n&gt;&gt;&gt;         print(port.device)\n</code></pre>"},{"location":"api/utils/#senxor.utils.list_camera","title":"<code>list_camera()</code>","text":"<p>List all cameras available.</p> Warning: <p>This function is deprecated. Use <code>list_camera_info</code> instead.</p> Returns: <p>list[str]     A list of camera names.</p> Examples: <p>list_camera() ['Camera 0', 'Camera 1', 'Camera 2']</p> <p>You can use <code>cv2.VideoCapture(index)</code> to open a camera.</p>"},{"location":"api/utils/#senxor.utils.list_senxor","title":"<code>list_senxor(type=None, exclude=None)</code>","text":"<p>List all Senxor devices available.</p> <p>The return value is a list of Senxor devices, use <code>senxor.connect</code> to connect to a device.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['serial'] | None</code> <p>The type of device to list. If not provided, all types will be listed.</p> <code>None</code> <code>exclude</code> <code>list[str] | str | None</code> <p>If <code>type</code> is provided, this will be ignored. A list of device names to exclude from the list. If not provided, all devices will be listed.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of Senxor devices, use <code>senxor.connect</code> to connect to a device.</p>"},{"location":"api/utils/#senxor.utils.list_senxor_usb","title":"<code>list_senxor_usb(exclude_open_ports=True)</code>","text":"<p>List all the senxor ports.</p> <p>Parameters:</p> Name Type Description Default <code>exclude_open_ports</code> <code>bool</code> <p>If True, exclude the ports that are currently open (in use). If False, include the ports that are currently open (in use). Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ListPortInfo]</code> <p>The list of senxor ports.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ports = list_senxor_ports()\n&gt;&gt;&gt; print([port.device for port in ports])\n['COM5', 'COM6']\n</code></pre>"},{"location":"api/utils/#senxor.utils.remap","title":"<code>remap(image, in_range=None, out_range=None, dtype=np.uint8)</code>","text":"<p>Remap image intensity to a desired range and data type using NumPy.</p> <p>It's equivalent to <code>normalize(..., dtype=np.uint8)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>The image to remap.</p> required <code>in_range</code> <code>tuple | None</code> <p>The input range of the image. If <code>None</code>, the image's min/max are used.</p> <code>None</code> <code>out_range</code> <code>tuple | None</code> <p>The output range of the image.</p> <code>None</code> <code>dtype</code> <code>Any</code> <p>The data type of the image.</p> <code>uint8</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The remapped image.</p>"},{"location":"examples/basic_stream/","title":"Basic Stream","text":"<p>This example shows how to stream frames from a Senxor device and display them in a window using cv2.</p> <pre><code>\"\"\"A basic example of how to stream frames from a Senxor device and display them in a window using cv2.\"\"\"\n\nimport numpy as np\n\ntry:\n    import cv2\nexcept ImportError:\n    print(\"Required packages are not installed.\")\n    exit(1)\n\nimport senxor\nfrom senxor.log import setup_console_logger\nfrom senxor.proc import apply_colormap, enlarge, get_colormaps, normalize\n\n# Choose the colormap `inferno` from the built-in cv2 colormaps.\n# This method does not require the cv2 package actually.\ncmap = get_colormaps(\"inferno\", namespace=\"cv\", n=1024)\n\nif __name__ == \"__main__\":\n    # Setup the logger based on structlog.\n    # This is optional.\n    setup_console_logger()\n\n    # List all available devices.\n    serials = senxor.list_senxor(\"serial\")\n\n    # Use the `with` statement to ensure the connection is closed after the block.\n    with senxor.connect(serials[0], \"serial\") as dev:\n        # Start the stream.\n        dev.start_stream()\n\n        while True:\n            # Call the `read` function to get the next frame.\n            header, frame = dev.read(block=True)\n\n            if frame is not None:\n                # Let's say we're looking at a typical thermal image where temps are around 20-70\u00b0C.\n                # These images can have 500+ distinct values to show tiny temperature differences.\n                # Converting straight to uint8 grayscale (0-255) would cut our detail in half - not great!\n                # That's why we first convert to float32 - it keeps all the original temperature info intact.\n                image = normalize(frame, dtype=np.float32)\n\n                # Now for adding colors - here's the tricky part:\n                # Regular cv2.applyColorMap needs uint8 input and only has 256 colors to work with.\n                # Using that would mean losing half our temperature detail again. Not what we want!\n                # Instead, we use senxor.proc.get_colormaps to get more colors (bigger LUT)\n                # and senxor.proc.apply_colormap to work directly with our detailed float32 image.\n\n                # The uint8 parameter means the output image will be converted to uint8 after applying the colormap.\n                # Converting to uint8 after applying the colormap is recommended since:\n                # 1. uint8 RGB provides 16M colors (256^3).\n                # 2. Most GUI frameworks expect uint8 RGB images as input\n                image = apply_colormap(image, cmap)\n\n                # Enlarge the image to make it easier to see.\n                image = enlarge(image, 3)\n\n                # The `apply_colormap` returns a RGB image, so we need to convert it to BGR to display it with cv2.\n                image_bgr = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)\n                cv2.imshow(\"senxor\", image_bgr)\n\n                if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n                    break\n\n        cv2.destroyAllWindows()\n        dev.stop_stream()\n</code></pre>"},{"location":"examples/thread_stream/","title":"Use Thread to Stream Frames","text":"<p>This example shows how to use threads to stream frames from a Senxor device and display them in a window using cv2.</p> <pre><code>\"\"\"Basic example demonstrating senxor.thread.SenxorThread.\"\"\"\n\nfrom __future__ import annotations\n\nimport time\nfrom typing import TYPE_CHECKING\n\nfrom senxor import Senxor, list_senxor\nfrom senxor.thread import SenxorThread\n\nif TYPE_CHECKING:\n    import numpy as np\n\n\ndef on_senxor_data(_: np.ndarray | None, data: np.ndarray | None):\n    if data is None:\n        return\n    print(f\"Temperature: max: {data.max():.1f}, min: {data.min():.1f}, mean: {data.mean():.1f}\")\n\n\ndef main():\n    # Search for available Senxor devices\n    devices = list_senxor()\n\n    if not devices:\n        exit(1)\n\n    address = devices[0]\n\n    try:\n        # Create and start a SenxorThread\n        senx = Senxor(address)\n        senxor_thread = SenxorThread(senx, on_senxor_data)\n        senxor_thread.start()\n\n        while True:\n            time.sleep(0.01)\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping stream...\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/v4l2-virtual-camera/","title":"<code>v4l2-virtual-camera.py</code>","text":"<p>This example, <code>v4l2-virtual-camera.py</code>, allows you to stream the thermal camera feed to a virtual video device using FFmpeg and v4l2loopback.</p> <p>You can find the source code at Here.</p>"},{"location":"examples/v4l2-virtual-camera/#features","title":"Features","text":"<ul> <li>Flexible Output Options: Supports local display of thermal images or streaming to a virtual video device (e.g., <code>/dev/video1</code>) using FFmpeg for integration with applications like Zoom, OBS, or VLC.</li> <li>Advanced Image Processing: Includes temporal smoothing, spatial median blur, and optional CLAHE (Contrast Limited Adaptive Histogram Equalization) for enhanced image quality.</li> <li>Customizable Parameters: Allows configuration of colormap, emissivity, scaling factor, and smoothing levels via command-line arguments.</li> <li>Min/Max Temperature Annotation: Automatically annotates the minimum and maximum temperature points on the displayed or streamed image.</li> <li>Clean Exit Handling: Gracefully handles interruptions (e.g., Ctrl+C) to ensure proper cleanup of camera resources and windows.</li> </ul>"},{"location":"examples/v4l2-virtual-camera/#usage-examples","title":"Usage Examples","text":"<ul> <li>Local Display:   <pre><code>python thermal_toolbox.py --scale 6 --colormap viridis --smoothing-level 7\n</code></pre></li> <li>Streaming to Virtual Camera (requires FFmpeg and v4l2loopback):   <pre><code>python thermal_toolbox.py --stream | ffmpeg -f rawvideo -pixel_format rgb24 -video_size 640x480 -framerate 5 -i - -f v4l2 /dev/video1\n</code></pre></li> </ul>"},{"location":"examples/v4l2-virtual-camera/#advantages","title":"Advantages","text":"<ul> <li>Versatility: Seamlessly switch between local visualization and streaming, making it ideal for diverse use cases like live monitoring or video conferencing.</li> <li>Enhanced Image Quality: Advanced processing options improve clarity and reduce noise in thermal images.</li> <li>User-Friendly: Intuitive command-line interface with sensible defaults for quick setup.</li> <li>Integration with C++ Version: This Python example complements the C++ MI48Dx Serial Driver (HefnySco/mi48dx-serial-driver), which offers a lightweight alternative for processing raw binary data streams and converting 16-bit pixel values into Kelvin temperatures with frame statistics (MIN/MAX/AVG). The C++ version is ideal for performance-critical applications or environments where Python dependencies are a constraint.</li> </ul>"},{"location":"examples/v4l2-virtual-camera/#c-alternative","title":"C++ Alternative","text":"<p>For a lower-level, high-performance interface to the MI48 thermal imaging sensor, check out the C++ MI48Dx Serial Driver. It provides direct access to raw data streams and is optimized for minimal overhead, making it suitable for embedded systems or real-time applications.</p>"},{"location":"guides/device_control/","title":"Device Control and Status","text":"<p>Most day-to-day interaction with a SenXor device happens through its registers (raw 8-bit values) and the higher-level fields (individual bits or bit-ranges inside those registers). This page shows you how to inspect device status and apply configuration changes using these two powerful APIs.</p>"},{"location":"guides/device_control/#how-the-register-system-works","title":"How the Register System Works","text":"<p>The core of every SenXor device is the MI48 chip, which exposes a bank of 8-bit registers. Each register has:</p> <ul> <li>Address (e.g., <code>0xB1</code>)</li> <li>Value (e.g., <code>0b00000000</code>)</li> </ul> <p>To save space, small pieces of configuration, called fields, are packed into those 8-bit registers. Each field represents a specific function or status bit, and several fields may share a single register.</p>"},{"location":"guides/device_control/#example-unpacking-a-register","title":"Example: Unpacking a Register","text":"<p>Take the <code>FRAME_MODE</code> register at address <code>0xB1</code> as an example. It's an 8-bit value structured as follows:</p> Bit 7 Bit 6 Bit 5 Bits 4-2 Bit 1 Bit 0 Reserved Reserved NO_HEADER READOUT_MODE CONTINUOUS_STREAM GET_SINGLE_FRAME <p>Instead of forcing you to do binary math (like <code>(value &amp; 0b00000010) &gt;&gt; 1</code>), <code>pysenxor</code> provides a simple, name-based API: <code>dev.fields.CONTINUOUS_STREAM</code>.</p>"},{"location":"guides/device_control/#getting-help-discovering-registers-and-fields","title":"Getting Help: Discovering Registers and Fields","text":"<p>After connecting to your device (see Quick Start for details), you can easily explore available registers and fields, as well as their descriptions and help texts.</p> <pre><code>&gt;&gt;&gt; import senxor\n&gt;&gt;&gt; addrs = senxor.list_senxor()\n&gt;&gt;&gt; addrs\n['COM3']\n&gt;&gt;&gt; dev = senxor.connect(addrs[0])\n&gt;&gt;&gt; print(f\"Connected to device {dev.address}\")\nConnected to device COM3\n</code></pre>"},{"location":"guides/device_control/#inspecting-registers","title":"Inspecting Registers","text":"<pre><code>&gt;&gt;&gt; regs = dev.regs\n&gt;&gt;&gt; print(regs.FRAME_MODE)\nFRAME_MODE (0xB1)\n&gt;&gt;&gt; print(regs.FRAME_MODE.desc)\nControl capture and readout of thermal data\n</code></pre>"},{"location":"guides/device_control/#inspecting-fields","title":"Inspecting Fields","text":"<pre><code>fields = dev.fields\nprint(fields.FRAME_RATE_DIVIDER)\nprint(fields.FRAME_RATE_DIVIDER.desc)\nprint(fields.FRAME_RATE_DIVIDER.help)\n</code></pre> <p>All <code>regs</code> and <code>fields</code> support autocompletion in most editors.</p> <p>You can also access register and field metadata statically, without connecting to a device:</p> <pre><code>from senxor.regmap import Fields, Registers\nprint(Fields.FRAME_RATE_DIVIDER.desc)\nprint(Registers.FRAME_MODE.desc)\n</code></pre>"},{"location":"guides/device_control/#reading-device-status-and-configuration","title":"Reading Device Status and Configuration","text":"<p>You can use fields and registers to read device information, configuration, and status.</p>"},{"location":"guides/device_control/#example-reading-device-information","title":"Example: Reading Device Information","text":"<pre><code>&gt;&gt;&gt; mcu_type = dev.fields.MCU_TYPE\n&gt;&gt;&gt; mcu_type.get(), mcu_type.display()\n(3, 'MI48G')\n</code></pre> <p>The <code>.display()</code> method provides a human-readable string for enumerated or mapped values.</p>"},{"location":"guides/device_control/#example-reading-device-configuration","title":"Example: Reading Device Configuration","text":"<pre><code>&gt;&gt;&gt; emissivity = dev.fields.EMISSIVITY\n&gt;&gt;&gt; emissivity.display()\n'56%'\n\n&gt;&gt;&gt; dev.fields.OTF.display()\n'1.06'\n\n# Dictionary-style access\n&gt;&gt;&gt; dev.fields[\"OTF\"].get()\n6\n</code></pre>"},{"location":"guides/device_control/#example-reading-device-status","title":"Example: Reading Device Status","text":"<p>Some fields and registers reflect the device's current state. For general usage. For example:</p> <pre><code>&gt;&gt;&gt; dev.fields.CONTINUOUS_STREAM.get()\n0  # 0 = disabled, 1 = enabled\n\n&gt;&gt;&gt; dev.regs.FRAME_MODE.get()\n0b00000000\n</code></pre>"},{"location":"guides/device_control/#understanding-caching-and-io","title":"Understanding Caching and IO","text":"<p>The <code>.get()</code> method on registers and fields reads the value from the device and caches it. Subsequent <code>.get()</code> calls will return the cached value, unless the register/field is marked as auto-reset (i.e., its value may change due to hardware events).</p> <p>For example, <code>DATA_READY</code> indicates the frame data readiness status: if <code>DATA_READY</code> is 0, the frame data is not ready; if it is 1, the frame data is ready.</p> <p>For auto-reset fields (such as <code>DATA_READY</code>), <code>.get()</code> always queries the device directly, bypassing the cache. Frequent polling of such fields may impact device performance, especially for high-frequency operations.</p> <p>The <code>.display()</code> and <code>.value</code> properties both call <code>.get()</code> internally.</p> <p>To force a direct hardware read and update the cache, use the <code>.read()</code> method on registers:</p> <pre><code>fresh_value = dev.regs.FRAME_MODE.read()\n</code></pre> <p>If you want a snapshot of all cached values (without triggering any IO), use:</p> <pre><code>cached_regs = dev.regs.status\ncached_fields = dev.fields.status\n</code></pre>"},{"location":"guides/device_control/#when-and-why-to-call-refresh_regmap","title":"When (and Why) to Call <code>refresh_regmap()</code>","text":"<p>Sometimes you need a full, up-to-date picture of the device's configuration\u2014for example, right before saving a diagnostic log or after an external system has modified the camera settings. Instead of crawling through every register one-by-one (which could generate hundreds of I/O transactions), you can issue a single bulk read:</p> <pre><code>dev.refresh_regmap()  # single round-trip to the device\n</code></pre> <p>What just happened?</p> <ol> <li>The library performed one low-level operation to read all registers.</li> <li>Both register and field caches were refreshed in RAM.</li> <li>Subsequent <code>.get()</code> calls will now hit the fresh cache, keeping I/O traffic to zero until you ask for another live read.</li> </ol> <p>Performance Tip \u2013 For normal UI updates or tight acquisition loops, rely on cached values (<code>.status</code>) and refresh only when real-time accuracy is essential. A polling rate faster than 10 Hz (every 100 ms) is generally unnecessary and may congest the bus.</p>"},{"location":"guides/device_control/#configuring-the-device","title":"Configuring the Device","text":"<p>You can change device settings by writing to fields or registers. The recommended way is to use field-level access for clarity and safety.</p>"},{"location":"guides/device_control/#example-setting-the-frame-rate","title":"Example: Setting the Frame Rate","text":"<pre><code>&gt;&gt;&gt; dev.fields.FRAME_RATE_DIVIDER.get()\n4\n&gt;&gt;&gt; dev.fields.FRAME_RATE_DIVIDER.set(1)\n&gt;&gt;&gt; dev.fields.FRAME_RATE_DIVIDER.get()\n1\n</code></pre>"},{"location":"guides/device_control/#example-adjusting-emissivity","title":"Example: Adjusting Emissivity","text":"<pre><code>&gt;&gt;&gt; dev.fields.EMISSIVITY.set(98)\n&gt;&gt;&gt; dev.fields.EMISSIVITY.get()\n98\n</code></pre>"},{"location":"guides/device_control/#alternative-apis-and-best-practices","title":"Alternative APIs and Best Practices","text":"<p>While attribute-style access (<code>dev.fields.FIELD_NAME</code>) is recommended for its clarity and auto-completion support, other helpers exist:</p> <ul> <li>Dictionary access \u2013 <code>dev.fields[\"FIELD_NAME\"]</code></li> <li>Register-level direct access \u2013 <code>dev.regs.read_reg(0xCA)</code> and <code>dev.regs.write_reg(0xCA, 98)</code></li> <li>Batch operations \u2013 <code>dev.regs.read_regs([0x00, 0x01, 0xB1])</code> or <code>dev.fields.set_fields({\"FRAME_RATE_DIVIDER\": 2, \"EMISSIVITY\": 90})</code></li> <li>Iteration \u2013   <pre><code>&gt;&gt;&gt; for reg in dev.regs:\n...     print(hex(reg.addr), reg.name)\n&gt;&gt;&gt; for field in dev.fields:\n...     print(field.name)\n</code></pre></li> </ul> <p>For more details, please refer to the API Reference.</p>"},{"location":"guides/device_control/#best-practices","title":"Best Practices","text":"<ul> <li>Prefer fields when available \u2013 less bit-twiddling, fewer mistakes.</li> <li>Refresh sparingly \u2013 call <code>refresh_regmap()</code> only when you need a full, live snapshot.</li> <li>Leverage <code>.display()</code> \u2013 convert raw values into human-readable strings.</li> <li>Monitor error flags \u2013 e.g., <code>dev.fields.CAPTURE_ERROR</code> \u2013 to keep your application robust.</li> </ul>"},{"location":"guides/getting_started/","title":"Getting Started","text":""},{"location":"guides/getting_started/#import","title":"Import","text":"<pre><code>import senxor\n</code></pre>"},{"location":"guides/getting_started/#list-available-devices","title":"List available devices","text":"<p>You can list all available devices by calling the <code>list_senxor</code> function.</p> <pre><code>addrs = senxor.list_senxor()\nfor addr in addrs:\n    print(addr)\n</code></pre> <p>You can also specify the type of device to list.</p> <pre><code>addrs = senxor.list_senxor(\"serial\") # list all usb serial devices\n</code></pre>"},{"location":"guides/getting_started/#connect-to-senxor","title":"Connect to senxor","text":"<p>Once you have the device address, you can connect to the device.</p> <p>There are several ways to connect to a Senxor device.</p> <ol> <li>Use the context manager provided by the <code>connect</code> function.</li> </ol> <pre><code>addr = addrs[0]\n\nwith senxor.connect(addr, \"serial\") as dev:\n    print(dev.is_connected)\n\nprint(dev.is_connected)\n</code></pre> <p>The <code>with</code> statement will ensure that the connection is closed after the block is executed.</p> <p>It's equivalent to:</p> <pre><code>dev = senxor.connect(addr, \"serial\")\nprint(dev.is_connected)\ndev.close()\n</code></pre> <p>You can also use the <code>connect</code> without specifying the address or type.</p> <p>In this case, the function will automatically find the first available device.</p> <pre><code>dev = senxor.connect()\nprint(dev.is_connected)\n</code></pre> <p>To be compatible with the old version, below is the equivalent code.</p> <pre><code>from senxor.utils import connect, connect_senxor\n\ndev = connect()\nprint(dev.is_connected)\n\ndev = connect_senxor()\nprint(dev.is_connected)\n</code></pre>"},{"location":"guides/getting_started/#start-stream-and-read-data","title":"Start Stream and Read Data","text":"<p>Once you have connected to the device, you can start the stream and read data from the device.</p> <pre><code>dev.start_stream()\n\nheader, frame = dev.read()\n\nif frame is not None:\n    print(f\"Frame shape: {frame.shape}, dtype: {frame.dtype}\")\n    # Output: Frame shape: (120, 160), dtype: float32\n\n    print(f\"Frame min: {frame.min()} C, max: {frame.max()} C, mean: {frame.mean():.1f} C\")\n    # Output: Frame min: 20.3 C, max: 34.1 C, mean: 27.2 C\n\ndev.close() # Stop the stream and close the connection\n</code></pre> <p>The <code>read</code> method will return a tuple of <code>(header, frame)</code> or <code>(None, None)</code> if the frame is not available(if block is False).</p> <p>The <code>header</code> is a uint16 np.ndarray with some information about the frame.</p> <p>In default, the <code>frame</code> is a 2D float32 np.ndarray, which is the temperature in Celsius.</p> <p>The <code>read</code> method is default in blocking mode, which means it will wait until a new frame is available.</p> <p>You can set the <code>block</code> parameter to <code>False</code> to make the <code>read</code> method non-blocking.</p> <pre><code>header, frame = dev.read(block=False)\nif frame is None:\n    print(\"No new frame is available\")\n</code></pre>"},{"location":"guides/getting_started/#process-the-data","title":"Process the data","text":"<p>You can use the <code>senxor.proc</code> module to process the data.</p> <pre><code>import senxor.proc\n</code></pre> <p>Convert the frame to uint8 grayscale image.</p> <p>Note: Due to the uint8 grayscale image has only 256 possible values, some information of the temperature frame may be lost.</p> <pre><code>uint8_image = senxor.proc.normalize(frame, dtype=np.uint8)\n\n# Or use the `remap`, it's equivalent to `normalize(frame, dtype=np.uint8)`\nuint8_image = senxor.proc.remap(frame)\n</code></pre> <p>Convert the frame to float32 grayscale image.</p> <p>The float grayscale image can keep all the information of the temperature frame.</p> <pre><code>float32_image = senxor.proc.normalize(frame, dtype=np.float32)\n</code></pre> <p>Simply enlarge the image with a integer scale factor.</p> <pre><code>enlarged_image = senxor.proc.enlarge(frame, scale=2) # only support integer scale factor\n</code></pre> <p>Get a built-in cv2 colormap or matplotlib colormap.</p> <pre><code>cmap_cv_inferno = senxor.proc.get_colormap(\"inferno\", \"cv\")\ncmap_mpl_inferno = senxor.proc.get_colormap(\"inferno\", \"mpl\")\n</code></pre> <p>Apply a colormap to the image.</p> <pre><code># This returns a RGB image\ncolored_image = senxor.proc.apply_colormap(frame, lut=cmap_cv_inferno)\n</code></pre> <p>Tip</p> <p>To keep the lightweight of the pysenxor, the <code>get_colormap</code> and <code>apply_colormap</code> doesn't need <code>cv2</code> or <code>matplotlib</code> as dependencies. They are based on the <code>colormap_tool</code> and <code>numpy</code> only.</p>"},{"location":"guides/getting_started/#display-or-save-the-thermal-image","title":"Display or save the thermal image","text":"<p>You can use the <code>cv2</code> or <code>matplotlib</code> to display or save the thermal image.</p> <pre><code>import cv2\n\n# Note: The cv2 uses BGR format instead of RGB format.\nbgr_image = cv2.cvtColor(colored_image, cv2.COLOR_RGB2BGR)\ncv2.imshow(\"senxor\", bgr_image)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n</code></pre> <pre><code>import matplotlib.pyplot as plt\n\nplt.imshow(colored_image)\nplt.show()\n</code></pre>"},{"location":"guides/getting_started/#device-control","title":"Device Control","text":"<pre><code>&gt;&gt;&gt; import senxor\n&gt;&gt;&gt; dev = senxor.connect(senxor.list_senxor()[0])\n</code></pre> <p>You can access device registers and fields through the <code>regs</code> and <code>fields</code> properties of the device object.</p> <pre><code># Get the MCU type value and display string\n&gt;&gt;&gt; dev.fields.MCU_TYPE.get(), dev.fields.MCU_TYPE.display()\n(3, 'MI48G')\n\n# Set the frame rate divider to 4\n&gt;&gt;&gt; dev.fields.FRAME_RATE_DIVIDER.set(4)\n\n# print the help string of a field\n&gt;&gt;&gt; print(dev.fields.FRAME_RATE_DIVIDER.help)\n\n# Get all fields value as a dictionary\n&gt;&gt;&gt; dev.fields.status\n{'MCU_TYPE': 3, 'FW_VERSION_MAJOR': 4, 'FW_VERSION_MINOR': 5, ...}\n</code></pre>"},{"location":"guides/getting_started/#logging","title":"Logging","text":"<p>You can enable logging to see debug information.</p> <pre><code>from senxor.log import setup_console_logger\n\n# Must be called before any other code.\nsetup_console_logger()\n</code></pre> <p>Example output:</p> <pre><code>2025-10-27T11:34:17+0800 [info     ] init Senxor                    address=&lt;serial.tools.list_ports_common.ListPortInfo object at 0x000001458BC88320&gt; type=serial auto_open=True\n2025-10-27T11:34:17+0800 [info     ] registers read                 address=COM4 addrs=[177] values={177: 32}\n2025-10-27T11:34:17+0800 [info     ] refresh fields by reg-read     address=COM4 fields={'NO_HEADER': 1, 'ADC_ENABLE': 0, 'GET_SINGLE_FRAME': 0, 'READOUT_MODE': 0, 'CONTINUOUS_STREAM': 0}\n2025-10-27T11:34:17+0800 [info     ] registers write                address=COM4 updates={177: 32}\n2025-10-27T11:34:17+0800 [info     ] stop stream                    address=COM4\n</code></pre>"},{"location":"guides/getting_started/#multi-threading","title":"Multi-threading","text":"<p><code>senxor</code> is designed to be thread-safe.</p> <p>You can interact with the device in multiple threads.</p> <p>For example, you can read the data in a background thread, and read/write registers in the main thread. Which is useful for GUI applications.</p>"},{"location":"guides/getting_started/#_1","title":"Getting Started","text":""},{"location":"guides/loading_settings/","title":"Loading Settings from Files","text":"<p>pysenxor provides a powerful configuration system that allows you to load device settings from files and automatically apply them to SenXor devices. This system supports conditional configuration, enabling automatic selection of appropriate settings based on the device's current state (such as frame size, device type, etc.).</p>"},{"location":"guides/loading_settings/#configuration-file-format","title":"Configuration File Format","text":"<p>The configuration system supports three file formats: YAML, TOML, and JSON. All formats follow the same structure:</p>"},{"location":"guides/loading_settings/#basic-structure","title":"Basic Structure","text":"<pre><code>profiles:\n  - name: \"profile_name\"\n    desc: \"profile_description\" # optional\n    when: \"condition_expression\" # optional\n    settings:\n      field_1: value\n      field_2: value\n</code></pre>"},{"location":"guides/loading_settings/#yaml-format-example","title":"YAML Format Example","text":"<pre><code>profiles:\n  - name: \"default\"\n    desc: \"Default settings for general use\"\n    settings:\n      EMISSIVITY: 83\n      FRAME_RATE_DIVIDER: 4\n\n  - name: \"Panther\"\n    desc: \"Special settings for Panther Module\" # Panther Module has image size: w:160, h:120\n    when: \"frame_shape == (120, 160)\"\n    settings:\n      STARK_ENABLE: false\n      EMISSIVITY: 95\n</code></pre>"},{"location":"guides/loading_settings/#toml-format-example","title":"TOML Format Example","text":"<pre><code>[[profiles]]\nname = \"default\"\ndesc = \"Default settings for general use\"\n[profiles.settings]\nEMISSIVITY = 83\nFRAME_RATE_DIVIDER = 4\n\n[[profiles]]\nname = \"Panther\"\ndesc = \"Special settings for Panther Module\"\nwhen = \"frame_shape == (120, 160)\"\n[profiles.settings]\nSTARK_ENABLE = false\nEMISSIVITY = 95\n</code></pre>"},{"location":"guides/loading_settings/#json-format-example","title":"JSON Format Example","text":"<pre><code>{\n  \"profiles\": [\n    {\n      \"name\": \"default\",\n      \"desc\": \"Default settings for general use\",\n      \"settings\": {\n        \"EMISSIVITY\": 83,\n        \"FRAME_RATE_DIVIDER\": 4\n      }\n    },\n    {\n      \"name\": \"Panther\",\n      \"desc\": \"Special settings for Panther Module\",\n      \"when\": \"frame_shape == (120, 160)\",\n      \"settings\": {\n        \"STARK_ENABLE\": false,\n        \"EMISSIVITY\": 95\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/loading_settings/#conditional-expressions-when-field","title":"Conditional Expressions (when field)","text":"<p>The <code>when</code> field allows you to conditionally apply configurations based on the device's current state. Conditional expressions use Python syntax and support the following operations:</p>"},{"location":"guides/loading_settings/#supported-syntax","title":"Supported Syntax","text":"<ul> <li>Comparison operators: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li> <li>Logical operators: <code>and</code>, <code>or</code>, <code>not</code></li> <li>Variables: Device properties and field values</li> <li>Constants: Numbers, strings, boolean values</li> </ul>"},{"location":"guides/loading_settings/#available-context-variables","title":"Available Context Variables","text":"<p>Conditional expressions can access the following device information:</p> Variable Name Type Description <code>frame_shape</code> tuple Device frame size, e.g., <code>(120, 160)</code> <code>address</code> str Device address, e.g., <code>\"COM3\"</code> <code>type</code> str Device type <code>[field_name]</code> int Current value of any non-auto-reset field"},{"location":"guides/loading_settings/#usage","title":"Usage","text":""},{"location":"guides/loading_settings/#loading-configuration-from-file","title":"Loading Configuration from File","text":"<pre><code>from senxor import connect\nfrom senxor.settings import load, apply\n\n# Load configuration from file\nsettings = load(\"my_settings.yaml\")\n\n# Connect to device\nwith connect() as senxor:\n    # Apply configuration\n    apply(senxor, settings)\n</code></pre>"},{"location":"guides/loading_settings/#loading-configuration-from-various-sources","title":"Loading Configuration from Various Sources","text":"<p>The <code>loads</code> function is designed to handle non-standard configuration sources such as network-transmitted byte streams, already opened file handles, or configuration data received from external systems.</p> <pre><code>from senxor.settings import loads, apply\n\n# From a file handle\nwith open(\"config.yaml\", \"r\") as f:\n    settings = loads(f, filetype=\"yaml\")\n\n# From bytes (e.g., network transmission)\nconfig_bytes = b\"\"\"\nprofiles:\n  - name: \"default\"\n    settings:\n      OTF: 2\n      EMISSIVITY: 83\n  - name: \"panther\"\n    when: \"frame_shape == (120, 160)\"\n    settings:\n      STARK_ENABLE: false\n      MEDIAN_ENABLE: false\n\"\"\"\nsettings = loads(config_bytes, filetype=\"yaml\")\n</code></pre>"},{"location":"guides/loading_settings/#applying-single-configuration","title":"Applying Single Configuration","text":"<pre><code># Apply specific configuration\nprofile = settings[\"default\"]\napply(senxor, profile)\n</code></pre>"},{"location":"guides/loading_settings/#practical-examples","title":"Practical Examples","text":""},{"location":"guides/loading_settings/#example-1-module-specific-settings","title":"Example 1: Module-specific settings","text":"<pre><code># module_config.yaml\nprofiles:\n  - name: \"panther_module\"\n    desc: \"Panther Module specific settings\"\n    when: \"frame_shape == (120, 160)\"\n    settings:\n      STARK_ENABLE: false\n      MEDIAN_ENABLE: false\n      EMISSIVITY: 85\n      FRAME_RATE_DIVIDER: 2\n\n  - name: \"cougar_module\"\n    desc: \"Cougar Module specific settings\"\n    when: \"frame_shape == (60, 80)\"\n    settings:\n      STARK_ENABLE: true\n      MEDIAN_ENABLE: true\n      EMISSIVITY: 90\n      FRAME_RATE_DIVIDER: 3\n</code></pre> <pre><code>from senxor import connect\nfrom senxor.settings import load, apply\n\nwith connect() as senxor:\n    settings = load(\"module_config.yaml\")\n    apply(senxor, settings)\n    print(f\"Applied configuration for {senxor.get_shape()} device\")\n</code></pre>"},{"location":"guides/loading_settings/#example-2-firmware-version-based-configuration","title":"Example 2: Firmware Version-Based Configuration","text":"<pre><code># firmware_config.yaml\nprofiles:\n  - name: \"legacy_firmware\"\n    desc: \"Settings for older firmware versions\"\n    when: \"(FW_VERSION_MAJOR, FW_VERSION_MINOR) &lt; (4, 3)\"\n    settings:\n      STARK_ENABLE: true\n      MEDIAN_ENABLE: true\n      TEMPORAL_ENABLE: true\n      FRAME_RATE_DIVIDER: 4\n\n  - name: \"modern_firmware\"\n    desc: \"Settings for newer firmware versions with enhanced features\"\n    when: \"(FW_VERSION_MAJOR, FW_VERSION_MINOR) &gt;= (4, 3)\"\n    settings:\n      STARK_ENABLE: false\n      MEDIAN_ENABLE: false\n      TEMPORAL_ENABLE: false\n      FRAME_RATE_DIVIDER: 2\n</code></pre>"}]}